#############################################################################
#  Copyright (C) 2010-2011 NTT
#############################################################################

#####################################################################
# Function: CParser.yp
#
#
# 概要:
# C言語ソースコードを構文解析するための構文規則を定義する。本ソース
# コードは、Parser::Yappモジュールによりパーサに変換される。
#
# 特記事項:
# なし
#
#####################################################################

#!
#! headerセクションに記述するコメントについて
#! headerセクションに記述するコメントは「#!」で記述する。
#! これは、NaturalDocsに余分な出力を行わせないための措置である。
#!

#!
#! shift/reduce規則の定義
#!
%right LCB_TOKEN LSB_TOKEN LP_TOKEN LT_OPR
%left  RCB_TOKEN RSB_TOKEN
#%left  REDUCE_

#!
#! 先頭ルールの定
#!
%start translation_unit

#!
#! 処理ロジックの定義
#!
%{
#use diagnostics;
use warnings;
no warnings "recursion";
use strict;
use Carp;
use utf8;
use PgSqlExtract::Common::Lexer;
use PgSqlExtract::Common;
use Scalar::Util;

#!
#! 識別子(Identifiers)の定義
#!
my $Identifiers = qr{ ( [\w_\$][\w\d_\$]* ) }xms;

#!
#! キーワード（予約語）の定義
#!
my %keywords = (
	map { $_ => uc($_) . '_TOKEN' } qw(
		_Bool	_Complex	_Imaginary	auto		break		case		char
		const	continue	default		do			double		else		enum
		extern	float		for			goto		if			inline		int
		long	new			private		protected	public		register	restrict
		return	short		signed		sizeof		static		struct		switch
		typedef	union		unsigned	void		volatile	while
    ),
);

# SQLで使用するため、大文字でも解釈できるようにtoken登録する
my $Exec	= qr{\b[e][x][e][c]\b}ixms;
my $Sql	= qr{\b[s][q][l]\b}ixms;
my $Oracle	= qr{\b[o][r][a][c][l][e]\b}ixms;
my $Tools	= qr{\b[t][o][o][l][s]\b}ixms;
my $Begin	= qr{\b[b][e][g][i][n]\b}ixms;
my $End	= qr{\b[e][n][d]\b}ixms;
my $Declare	= qr{\b[d][e][c][l][a][r][e]\b}ixms;
my $Section	= qr{\b[s][e][c][t][i][o][n]\b}ixms;

#!
#! リテラルパターンの定義(Integer Literals)
#!
my $Digit					= qr{\d}xms;
my $HexDigit				= qr{[\da-fA-F]}xms;
my $OctDigit				= qr{[0-7]}xms;
my $IntegerTypeSuffix		= qr{[uU] (?: [l][l] | [L][L] ) | [uU] [lL]? | (?: [l][l] | [L][L] ) [uU]?  | [lL] [uU]?}xms;
my $DecimalNumeral			= qr{ 0 | [1-9] $Digit* }xms;

my $HexNumeral				= qr{ 0 [xX] $HexDigit+ }xms;

my $OctalNumeral			= qr{ 0 $OctDigit+ }xms;

my $DecimalIntegerLiteral	= qr{ $DecimalNumeral $IntegerTypeSuffix? }xms;
my $HexIntegerLiteral		= qr{ $HexNumeral     $IntegerTypeSuffix? }xms;
my $OctalIntegerLiteral		= qr{ $OctalNumeral   $IntegerTypeSuffix? }xms;
my $IntegerLiteral = qr{ $OctalIntegerLiteral | $HexIntegerLiteral | $DecimalIntegerLiteral }xms;

#!
#! リテラルパターンの定義(Floating-Point Literals)
#!
my $ExponentPart	= qr{ [eE] [+-]?\d+ }xms;
my $FloatTypeSuffix	= qr{ [fFlL] }xms;
my $HexSignificand	= qr{ 0 [xX] (?: $HexDigit+ \.? | $HexDigit* \. $HexDigit+) }xms;
my $BinaryExponentIndicator	= qr{ [pP] [+-]?\d+ }xms;


my $DecimalFPLiteral1 = qr{ $Digit+ \. $Digit* $ExponentPart? $FloatTypeSuffix?}xms;
my $DecimalFPLiteral2 = qr{         \. $Digit+ $ExponentPart? $FloatTypeSuffix?}xms;
my $DecimalFPLiteral3 = qr{            $Digit+ $ExponentPart  $FloatTypeSuffix?}xms;
my $HexadecimalFPLiteral = qr{ $HexSignificand $BinaryExponentIndicator $FloatTypeSuffix? }xms;
my $FloatLiteral = qr{ $DecimalFPLiteral1 | $DecimalFPLiteral2 | $DecimalFPLiteral3 | $HexadecimalFPLiteral }xms;
#!
#! リテラルパターンの定義(Character)
#! ''内に任意の文字列を記述可能とする定義としており、これは本来の定義とは
#! 異なるが、これは'\u000'といった記述に対応するためである。
#! コンパイルが正常終了したソースコードが解析対象となるため、下記の定義で
#! 字句解析を行っても問題ない。
#! ※ ワイド文字(L'')の対応が必要
#!
my $CharacterLiteral	= qr{ [L]? ['] (?: [^'\\] | \\[?avxbtnfr"'\\0-9] | \\[\n] )* ['] }xms;

#!
#! リテラルパターンの定義(String)
#! ※ ワイド文字列(L"": Lは大文字のみらしい)の対応が必要
#!
my $StringLiteral		= qr{ [L]? ["] (?: [^"\\] | \\[?avxbtnfr"'\\0-9] | \\[\n] )* ["] }xms;


#!
#! セパレータパターンの定義
#! セパレータパターンは、キーワードとして扱う
#! ただし、DOT_TOKENはfloat値との誤認識を避けるため、
#! 特殊キーワードとして定義する
#!
my %separator = (
	'(' => 'LP_TOKEN' ,
	')' => 'RP_TOKEN' ,
	';' => 'SMC_TOKEN',
	',' => 'CM_TOKEN' ,
);

while(my ($key, $value) = each %separator) {
	$keywords{$key} = $value;
}

#!
#! クエスションはキーワードとして扱う
#!
$keywords{'?'} = 'QUES_TOKEN';

#!
#! オペレータパターンの定義
#!
#! オペレータについては、'=', '+', '+='について個別に識別する。これは、式解析
#! での判断対象となるためである。
#! また、'*'、'<>'、'&'、についても個別に識別する。これは、構文を構成する文字
#! であるためである。
#! 他のオペレータについては字句解析の高速化のため個別には識別しない。
#!
#! パターンマッチによるオペレータの誤認識('&&'を'&''&'と認識するなど)を避ける
#! ように定義の順番を考慮すること
#!
#! shift演算子については、'>>'は、TypeArgumentsの入れ子(<String, Map<String,
#! String>>など)の終端と誤認識する場合があるため、GT_OPRの連続で定義する。
#! そのため、トークンとしては定義しない。
#!
my $oprAssignEqual	= qr{ = }xms;
my $oprAssignPls	= qr{ \+= }xms;
my $oprPlus			= qr{ \+ }xms;

my $oprAssign		= qr{ >{2,3}= | <{2}= | [*/&|^%-]= }xms;
my $oprCOr			= qr{\|\|}xms;
my $oprCAnd			= qr{&&}xms;
my $oprOr			= qr{\|}xms;
my $oprNor			= qr{\^}xms;
my $oprAmp			= qr{&}xms;
my $oprEquality		= qr{[=!]=}xms;
my $oprRelational	= qr{[<>]=}xms;
my $oprShift		= qr{>{2} | <{2}}xms; #! Cでは>>>がないため修正
my $oprMulti		= qr{[/%]}xms;
my $oprAsteri		= qr{ \* }xms;
my $oprMinus		= qr{ - }xms;
my $oprInEquality	= qr{ <> }xms;
my $oprGt			= qr{ > }xms;
my $oprLt			= qr{ < }xms;
my $oprPostfix		= qr{ \+\+ | -- }xms;
my $oprPrefix		= qr{[!~]}xms;
my $oprPointer		= qr{ -> }xms;

#!
#! 特殊キーワード
#! BNFによる構文定義のみでは表現が難しいものについては、字句解析で識別を行う
#! 方針とする
#! そのような特殊なキーワードを定義する
#! - Annotationを示す@は、@InterfaceとInterfaceで定義を共用するため、特殊定義
#!   とする
#!
my $atmark			= qr{@}xms;
my $ellipsis		= qr{[.][.][.]};
my $dot				= qr{[.]};

my $sepLcb				= qr{[\{]|[<][%]};
my $sepRcb				= qr{[\}]|[%][>]};
my $sepLsb				= qr{[\[]|[<][:]};
my $sepRsb				= qr{[\]]|[:][>]};
my $kwCln				= qr{[:]};

#!
#! レクサに定義するパターンの定義
#!
my @pattern = (

	#
	# 埋め込みSQLキーワード
	#
	$Exec,					'EXEC_TOKEN',
	$Sql,					'SQL_TOKEN',
	$Oracle,				'ORACLE_TOKEN',
	$Tools,					'TOOLS_TOKEN',
	$Begin,					'BEGIN_TOKEN',
	$End,					'END_TOKEN',
	$Declare,				'DECLARE_TOKEN',
	$Section,				'SECTION_TOKEN',

	#
	# リテラルパターン(Floating-Point Literals)
	#
	$FloatLiteral,		'FLOAT_LITERAL',

	#
	# リテラルパターン(Integer Literals)
	#
	$IntegerLiteral,		'INTEGER_LITERAL',

	#
	# リテラルパターン(Character)
	#
	$CharacterLiteral,		'CHAR_LITERAL',

	#
	# リテラルパターン(String)
	#
	$StringLiteral,			'STRING_LITERAL',

	#
	# 識別子
	#
	$Identifiers,			'IDENTIFIER_ORG',

	#
	# セパレータ
	# 大なり小なりより先に定義する必要がある
	#
	$sepLcb,				'LCB_TOKEN',
	$sepRcb,				'RCB_TOKEN',
	$sepLsb,				'LSB_TOKEN',
	$sepRsb,				'RSB_TOKEN',

	#
	# オペレータパターン
	# 定義する順番に注意する
	# マッチング対象の文字列長が長いものから定義する必要がある
	#
	$oprAssign,				'ASSIGN_OPR',
	$oprShift,				'SHIFT_OPR',
	$oprEquality,			'EQUALITY_OPR',
	$oprRelational,			'RELATIONAL_OPR',
	$oprAssignPls,			'ASSIGN_P_OPR',
	$oprCOr,				'COR_OPR',
	$oprCAnd,				'CAND_OPR',
	$oprPostfix,			'POSTFIX_OPR',
	$oprAssignEqual,		'EQUAL_OPR',
	$oprPlus,				'PLUS_OPR',
	$oprOr,					'OR_OPR',
	$oprNor,				'NOR_OPR',
	$oprAmp,				'AMP_OPR',
	$oprMulti,				'MULTI_OPR',
	$oprAsteri,				'ASTARI_OPR',
	$oprPointer,			'PTR_OPR',
	$oprMinus,				'MINUS_OPR',
	$oprInEquality,			'INEQUALITY_OPR',
	$oprGt,					'GT_OPR',
	$oprLt,					'LT_OPR',
	$oprPrefix,				'PREFIX_OPR',
	$atmark,				'ATMARK_TOKEN',
	$ellipsis,				'ELLIPSIS_TOKEN',
	$dot,					'DOT_TOKEN',
	$kwCln,					'CLN_TOKEN',
);

#!
#! 解析対象外パターン(コメント、空白文字)の定義
#! '\s'は、空白、HT(水平タブ)、FF(フォームフィード)、改行(CR, LF, CR+LF)に
#! マッチングする
#!
my $commentPattern = q(
	(
		(?:  \s+
			| //[^\n]*
			| /\*.*?\*/
		)+
	)
);


#!
#! トークンIDの識別表を作成する
#! クラスメンバ変数の終端を示す特殊なトークンID「VARDECL_DELIMITER」を追加する
#!
my @tokenIdlist = values %keywords;
my $index = 0;
push(@tokenIdlist, grep { $index++ % 2 == 1 } @pattern);
map {$tokenId{$_} = $index++ } @tokenIdlist;
$tokenId{'VARDECL_DELIMITER'} = $index++;
$tokenId{'TNAME_TOKEN'} = $index++;

#!
#! キーワードに対するトークン情報オブジェクトプールを作成する
#! lookupは、トークン情報がプール対象であるかを判別するハッシュである
#! キーワード以外はプール対象としない（'VARDECL_DELIMITER'は特別なキーワード
#! としてプールする)
#!
my %G_tokenchace = ();
my %lookup = reverse %keywords;
$lookup{'VARDECL_DELIMITER'} = '##;##';


my $counter = 0;

#!
#! レクサの生成およびパターンの登録
#!
my $lex = PgSqlExtract::Common::Lexer->new();
$lex->setPattern({
	EXT_KEYWORD => \%keywords,
	EXT_PATTERN => \@pattern,
	SKIP_PATTERN => $commentPattern
});
$lex->setDebugMode(0);

#!
#! ノード種別の定義
#! ノード種別の比較にはequal_nodetype関数を使用する
#!
my $nodetypeid = 1;
my %nodetypehash = (
	map { $_ => $nodetypeid++ } qw(
 N_BlockStatements
 N_if N_else N_switch N_SwitchLabel N_while N_return N_ParExpression
 N_for N_ForControl N_forInit N_ForUpdate N_ForVarControl N_NormalFor
 N_ScopeInfo N_MetaNode N_Delimiter
 N_declaration N_declaration_specifiers N_type_specifier 
 N_init_declarator_list N_init_declarator
 N_expression N_assignment_operator N_logical_OR_expression N_logical_AND_expression
 N_inclusive_OR_expression N_exclusive_OR_expression N_AND_expression
 N_equality_expression N_relational_expression N_shift_expression
 N_additive_expression N_multiplicative_expression N_cast_expression
 N_unary_expression N_postfix_expression N_primary_expression
	),
);

#!
#! ノード種別のキャッシュ
#! scantree内で頻繁に使用される下記のノード種別については、値を別に保持する
#!
my $G_ScopeInfo_id	= $nodetypehash{'N_ScopeInfo'};
my $G_Delimiter_id	= $nodetypehash{'N_Delimiter'};
my $G_MetaNode_id	= $nodetypehash{'N_MetaNode'};
my $G_element_id	= 0;

#!
#! static擬似メソッドの付与ID
#! staticイニシャライザについては、擬似的なメソッドと解釈して解析を行う
#! その擬似的なメソッドのメソッド識別子に付与するIDである
#!
my $G_static_number = 0;

#!
#! ファイル情報へのリファレンス
#! クラス情報は、それを抽出した時点でファイル情報へ格納される
#!
my $G_fileinfo_ref;

#!
#! ホスト変数宣言フラグ
#! ホスト変数宣言内は真となるフラグ
#!
my $G_declaresection_flg = 0;

#!
#! 抽出したクラス名をスタックで管理する
#!
my @G_classname_ident = ();

#!
#! typedef宣言フラグ
#! typedef宣言内は真となるフラグ
#!
my $G_typedef_flg = 0;

#!
#! ANSI形式コメント行
#! ANSI形式コメント行が検出された場合に行数を格納する変数
#!
my $G_ansi_comment_line = 0;

#! 処理ロジック定義の終了
%}

#! token int_const char_const float_const id string enumeration_const
#! http://www.quut.com/c/ANSI-C-grammar-y.html
%%

# INTERNATIONAL STANDARD (C)ISO/IEC ISO/IEC 9899:TC2 
# Programming languages - C

# A.2 Phrase structure grammar
# A.2.1 Expressions
primary_expression
	: IDENTIFIER
	{
		printDebugLog("primary_expression:IDENTIFIER");
		['N_primary_expression', $_[1]];
	}
	| INTEGER_LITERAL	#! constantの中身を展開
	{
		printDebugLog("primary_expression:INTEGER_LITERAL");
		['N_primary_expression', $_[1]];
	}
	| FLOAT_LITERAL		#! constantの中身を展開
	{
		printDebugLog("primary_expression:FLOAT_LITERAL");
		['N_primary_expression', $_[1]];
	}
	| CHAR_LITERAL		#! constantの中身を展開
	{
		printDebugLog("primary_expression:CHAR_LITERAL");
		['N_primary_expression', $_[1]];
	}
	| string_literal_list
	{
		printDebugLog("primary_expression:string_literal_list");
        ['N_primary_expression', $_[1]];
    }
	| LP_TOKEN expression RP_TOKEN
	{
		printDebugLog("primary_expression:( expression )");
		['N_primary_expression', $_[2]];
	}
	;

string_literal_list
	: STRING_LITERAL
	{
		printDebugLog("string_literal_list:STRING_LITERAL");
        $_[1]->{TOKEN} =~ s{\A"}{}xms;
        $_[1]->{TOKEN} =~ s{"\z}{}xms;
        $_[1];
    }
	| string_literal_list STRING_LITERAL
	{
		printDebugLog("string_literal_list:string_literal_list STRING_LITERAL");
        $_[2]->{TOKEN} =~ s{\A"}{}xms;
        $_[2]->{TOKEN} =~ s{"\z}{}xms;
        $_[1]->{TOKEN} = $_[1]->{TOKEN} . $_[2]->{TOKEN};
		$_[1];
    }
	;

postfix_expression
	: primary_expression
	{
		printDebugLog("postfix_expression:primary_expression");
		$_[1];
	}
	| postfix_expression LSB_TOKEN expression RSB_TOKEN # 配列の要素の呼び出しは解析しない
	{
		printDebugLog("postfix_expression:postfix_expression [ expression ]");
		['N_postfix_expression' , $_[1]];
	}
	| postfix_expression LP_TOKEN argument_expression_list RP_TOKEN # 関数呼び出し（引数あり）
	{
		printDebugLog("postfix_expression:postfix_expression ( argument_expression_list )");
		['N_postfix_expression' , $_[1] , $_[2] , $_[3] , $_[4]];
	}
	| postfix_expression LP_TOKEN RP_TOKEN #! argument_expression_listのopt対処 # 関数呼び出し（引数なし）
	{
		printDebugLog("postfix_expression:postfix_expression ( )");
		['N_postfix_expression' , $_[1] , $_[2] , $_[3]];
	}
	| postfix_expression DOT_TOKEN IDENTIFIER # 構造体のメンバの呼び出し（.）は解析しない
	{
		printDebugLog("postfix_expression:postfix_expression . IDENTIFIER");
		['N_postfix_expression' , $_[1]];
	}
	| postfix_expression PTR_OPR IDENTIFIER # 構造体のメンバの呼び出し（->）解析しない
	{
		printDebugLog("postfix_expression:postfix_expression -> IDENTIFIER");
		['N_postfix_expression' , $_[1]];
	}
	| postfix_expression POSTFIX_OPR #! ++と--をあわせる # インクリメント/デクリメントは解析しない
	{
		printDebugLog("postfix_expression:postfix_expression [++|--]");
		['N_postfix_expression' , $_[1]];
	}
	| LP_TOKEN type_name RP_TOKEN LCB_TOKEN initializer_list RCB_TOKEN	# 例：(const float[]){1,2,3} は解析しない
	{
		printDebugLog("postfix_expression:( type_name ) { initializer_list }");
		['N_postfix_expression'];
	}
	| LP_TOKEN type_name RP_TOKEN LCB_TOKEN initializer_list CM_TOKEN RCB_TOKEN	# 例：(const float[]){1,2,} は解析しない
	{
		printDebugLog("postfix_expression:( type_name ) { initializer_list , }");
		['N_postfix_expression'];
	}
	;

argument_expression_list
	: assignment_expression
	{
		printDebugLog("argument_expression_list:assignment_expression");
		['N_argument_expression_list', $_[1]];
	}
	| argument_expression_list CM_TOKEN assignment_expression
	{
		printDebugLog("argument_expression_list:argument_expression_list , assignment_expression");
        push(@{$_[1]}, $_[2]);
        push(@{$_[1]}, $_[3]);
        $_[1];
	}
	;
#! 単項演算子は解析に必要ないため削除する
unary_expression
	: postfix_expression
	{
		printDebugLog("unary_expression:postfix_expression");
		$_[1];
	}
	| POSTFIX_OPR unary_expression #! ++と--をあわせる
	{
		printDebugLog("unary_expression:[++|--] unary_expression");
		['N_unary_expression', $_[2]];
	}
	| unary_operator cast_expression
	{
		printDebugLog("unary_expression:unary_operator cast_expression");
		['N_unary_expression', $_[2]];
	}
	| SIZEOF_TOKEN unary_expression
	{
		printDebugLog("unary_expression:sizeof unary_expression");
		['N_unary_expression', $_[2]];
	}
	| SIZEOF_TOKEN LP_TOKEN type_name RP_TOKEN
	{
		printDebugLog("unary_expression:sizeof ( type_name )");
		['N_unary_expression'];
	}
	;

unary_operator
	: AMP_OPR
	{
		printDebugLog("unary_operator:&");
		$_[1];
	}
	| ASTARI_OPR
	{
		printDebugLog("unary_operator:*");
		$_[1];
	}
	| PLUS_OPR
	{
		printDebugLog("unary_operator:+");
		$_[1];
	}
	| MINUS_OPR
	{
		printDebugLog("unary_operator:-");
		$_[1];
	}
	| PREFIX_OPR #! ~と!をあわせる
	{
		printDebugLog("unary_operator:!~");
		$_[1];
	}
	;

#! キャスト情報は解析に必要ないため削除する
cast_expression
	: unary_expression
	{
		printDebugLog("cast_expression:unary_expression");
		$_[1];
	}
	| LP_TOKEN type_name RP_TOKEN cast_expression
	{
		printDebugLog("cast_expression:( type_name ) cast_expression");
		['N_cast_expression', $_[4]];
	}
	;

multiplicative_expression
	: cast_expression
	{
		printDebugLog("multiplicative_expression:cast_expression");
		$_[1];
	}
	| multiplicative_expression ASTARI_OPR cast_expression
	{
		printDebugLog("multiplicative_expression:multiplicative_expression * cast_expression");
		['N_multiplicative_expression', $_[1], $_[2], $_[3]];
	}
	| multiplicative_expression MULTI_OPR cast_expression #! /と%をあわせる
	{
		printDebugLog("multiplicative_expression:multiplicative_expression [/|%] cast_expression");
		['N_multiplicative_expression', $_[1], $_[2], $_[3]];
	}
	;

additive_expression
	: multiplicative_expression
	{
		printDebugLog("additive_expression:multiplicative_expression");
		$_[1];
	}
	| additive_expression PLUS_OPR multiplicative_expression
	{
		printDebugLog("additive_expression:additive_expression + multiplicative_expression");
		['N_additive_expression', $_[1], $_[2], $_[3]];
	}
	| additive_expression MINUS_OPR multiplicative_expression
	{
		printDebugLog("additive_expression:additive_expression - multiplicative_expression");
		['N_additive_expression', $_[1], $_[2], $_[3]];
	}
	;

shift_expression
	: additive_expression
	{
		printDebugLog("shift_expression:additive_expression");
		$_[1];
	}
	| shift_expression SHIFT_OPR additive_expression #! <<と>>をあわせる
	{
		printDebugLog("shift_expression:shift_expression [<<|>>] additive_expression");
		['N_shift_expression', $_[1], $_[2], $_[3]];
	}
	;

relational_expression
	: shift_expression
	{
		printDebugLog("relational_expression:shift_expression");
		$_[1];
	}
	| relational_expression LT_OPR shift_expression
	{
		printDebugLog("relational_expression:relational_expression < shift_expression");
		['N_relational_expression', $_[1], $_[2], $_[3]];
	}
	| relational_expression GT_OPR shift_expression
	{
		printDebugLog("relational_expression:relational_expression > shift_expression");
		['N_relational_expression', $_[1], $_[2], $_[3]];
	}
	| relational_expression RELATIONAL_OPR shift_expression #! <=と>=をあわせる
	{
		printDebugLog("relational_expression:relational_expression [<=|=>] shift_expression");
		['N_relational_expression', $_[1], $_[2], $_[3]];
	}
	;

equality_expression
	: relational_expression
	{
		printDebugLog("equality_expression:relational_expression");
		$_[1];
	}
	| equality_expression EQUALITY_OPR relational_expression #! ==と!=をあわせる
	{
		printDebugLog("equality_expression:equality_expression [!|=]= relational_expression");
		['N_equality_expression', $_[1], $_[2], $_[3]];
	}
	;

AND_expression
	: equality_expression
	{
		printDebugLog("AND_expression:equality_expression");
		$_[1];
	}
	| AND_expression AMP_OPR equality_expression
	{
		printDebugLog("AND_expression:AND_expression & equality_expression");
		['N_AND_expression', $_[1], $_[2], $_[3]];
	}
	;

exclusive_OR_expression
	: AND_expression
	{
		printDebugLog("exclusive_OR_expression:AND_expression");
		$_[1];
	}
	| exclusive_OR_expression NOR_OPR AND_expression
	{
		printDebugLog("exclusive_OR_expression:exclusive_OR_expression ^ AND_expression");
		['N_exclusive_OR_expression', $_[1], $_[2], $_[3]];
	}
	;

inclusive_OR_expression
	: exclusive_OR_expression
	{
		printDebugLog("inclusive_OR_expression:exclusive_OR_expression");
		$_[1];
	}
	| inclusive_OR_expression OR_OPR exclusive_OR_expression
	{
		printDebugLog("inclusive_OR_expression:inclusive_OR_expression | exclusive_OR_expression");
		 ['N_inclusive_OR_expression', $_[1], $_[2], $_[3]];
	}
	;

logical_AND_expression
	: inclusive_OR_expression
	{
		printDebugLog("logical_AND_expression:inclusive_OR_expression");
		$_[1];
	}
	| logical_AND_expression CAND_OPR inclusive_OR_expression
	{
		printDebugLog("logical_AND_expression:logical_AND_expression && inclusive_OR_expression");
 		['N_logical_AND_expression', $_[1], $_[2], $_[3]];
	}
	;

logical_OR_expression
	: logical_AND_expression
	{
		printDebugLog("logical_OR_expression:logical_AND_expression");
		$_[1];
	}
	| logical_OR_expression COR_OPR logical_AND_expression
	{
		printDebugLog("logical_OR_expression:logical_OR_expression || logical_AND_expression");
		['N_logical_OR_expression', $_[1], $_[2], $_[3]];
	}
	;

conditional_expression
	: logical_OR_expression
	{
		printDebugLog("conditional_expression:logical_OR_expression");
		$_[1];
	}
	| logical_OR_expression QUES_TOKEN expression CLN_TOKEN conditional_expression
	{
		printDebugLog("conditional_expression:logical_OR_expression ? expression : conditional_expression");
		['N_logical_OR_expression', $_[1], $_[2], $_[3], $_[4], $_[5] ];
	}
	;

assignment_expression
	: conditional_expression
	{
		printDebugLog("assignment_expression:conditional_expression");
		$_[1];
	}
	| unary_expression assignment_operator assignment_expression
	{
		printDebugLog("assignment_expression:unary_expression assignment_operator assignment_expression");
        my $leftside = pop(@{$_[1]});
        push(@{$_[1]}, [ 'N_assignment_operator', $leftside, $_[2], $_[3] ]);
        $_[1];
	}
	;

assignment_operator
	: EQUAL_OPR
	| ASSIGN_OPR #! *=,/=,%=,-=,<<=,>>=,&=,^=,|=をあわせる
	| ASSIGN_P_OPR
	;

expression
	: assignment_expression
	{
		printDebugLog("expression:assignment_expression");
		['N_expression', $_[1]];
	}
	| expression CM_TOKEN assignment_expression
	{
		printDebugLog("expression:expression , assignment_expression");
        push(@{$_[1]}, $_[3]);
        $_[1];	
	}
	;

constant_expression
	: conditional_expression
	{
		printDebugLog("constant_expression:conditional_expression");
		$_[1];
	}
	;

# A.2.2 Declarations
declaration
	: declaration_specifiers init_declarator_list SMC_TOKEN
	{
		printDebugLog("declaration:declaration_specifiers init_declarator_list;");
		if(defined $_[1]->[1]){
			if($G_typedef_flg){
				$G_typedef_flg = 0;
                undef;
			}else{
			    {VARIABLE => [$_[1],$_[2]] };
            }
		}
		else{
			undef;
		}
	}
	| declaration_specifiers SMC_TOKEN #! init_declarator_list のopt対処 # ENUM宣言時に通るルートのため、ここでの解析を行わない	
	{
		printDebugLog("declaration:declaration_specifiers ;") ;
		undef;
	}
	;

declaration_specifiers
	: storage_class_specifier 		#! declaration_specifiers のopt対処	# 修飾子は行数のために取得する
	{
		printDebugLog("declaration_specifiers:storage_class_specifier");
		['N_declaration_specifiers', $_[1]];
	}
	| storage_class_specifier declaration_specifiers	# 修飾子は行数のために取得する
	{
		printDebugLog("declaration_specifiers:storage_class_specifier declaration_specifiers");
		shift @{$_[2]};
		unshift @{$_[2]} , $_[1];
		unshift @{$_[2]} , 'N_declaration_specifiers';
		$_[2];
	}
	| type_specifier 				#! declaration_specifiers のopt対処	#
	{
		printDebugLog("declaration_specifiers:type_specifier");
		['N_declaration_specifiers', $_[1]];
	}
	| type_specifier declaration_specifiers	
	{
		printDebugLog("declaration_specifiers:type_specifier declaration_specifiers");
		shift @{$_[2]};
		unshift @{$_[2]} , $_[1];
		unshift @{$_[2]} , 'N_declaration_specifiers';
		$_[2];
	}
	| type_qualifier 				#! declaration_specifiers のopt対処	# 修飾子は行数のために取得する
	{
		printDebugLog("declaration_specifiers:type_qualifier");
		['N_declaration_specifiers', $_[1]];
	}
	| type_qualifier declaration_specifiers	# 修飾子は行数のために取得する
	{
		printDebugLog("declaration_specifiers:type_qualifier declaration_specifiers");
		shift @{$_[2]};
		unshift @{$_[2]} , $_[1];
		unshift @{$_[2]} , 'N_declaration_specifiers';
		$_[2];
	}
	| function_specifier 			#! declaration_specifiers のopt対処 # 関数宣言は解析を行わない	
	{
		printDebugLog("declaration_specifiers:function_specifier");
		['N_declaration_specifiers'];
	}
	| function_specifier declaration_specifiers # 関数宣言は解析を行わない
	{
		printDebugLog("declaration_specifiers:function_specifier declaration_specifiers");
		$_[2];
	}
	;

init_declarator_list
	: init_declarator
	{
		printDebugLog("init_declarator_list:init_declarator");
		['N_init_declarator_list', $_[1]]
	}
	| init_declarator_list CM_TOKEN init_declarator
	{
		printDebugLog("init_declarator_list:init_declarator_list, init_declarator");
        push(@{$_[1]}, $_[2]); push(@{$_[1]}, $_[3]); 
        $_[1];
	}
	;

init_declarator
	: declarator
	{
		printDebugLog("init_declarator:declarator");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        if( !defined $decl->{type} or $decl->{type} ne 'ARRAY'){
        	$decl->{type} = 'NORMAL';
        }
		unshift @{$_[1]} , $metanode;
		unshift @{$_[1]} , 'N_init_declarator';
		if($G_typedef_flg){
		    if(exists($_[1]->[1]->[1]->{name})){
		        $lex->set_typedefname($_[1]->[1]->[1]->{name}->{TOKEN},0);
            }elsif(exists($_[1]->[1]->[1]->{TOKEN})){
                $lex->set_typedefname($_[1]->[1]->[1]->{TOKEN},0);
            }
        }
		$_[1];
	}
	| declarator EQUAL_OPR initializer
	{
		my @initializer;
		printDebugLog("init_declarator:declarator = initializer");
		push(@initializer , $_[2]);
		push(@initializer , $_[3]);
		
        my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        if( !defined $decl->{type} or $decl->{type} ne 'ARRAY'){
        	$decl->{type} = 'NORMAL';
        }
        $decl->{value} = $_[3];
		
		push(@{$_[1]} , @initializer);
		unshift @{$_[1]} , $metanode;
		unshift @{$_[1]} , 'N_init_declarator'; 
		$_[1];
	}
	;

storage_class_specifier
	: TYPEDEF_TOKEN
	{
		$G_typedef_flg = 1;
		printDebugLog("storage_class_specifier:TYPEDEF_TOKEN");
        $_[1];
	}
	| EXTERN_TOKEN
	{
		printDebugLog("storage_class_specifier:EXTERN_TOKEN");
        $_[1];
	}
	| STATIC_TOKEN
	{
		printDebugLog("storage_class_specifier:STATIC_TOKEN");
        $_[1];
	}
	| AUTO_TOKEN
	{
		printDebugLog("storage_class_specifier:AUTO_TOKEN");
        $_[1];
	}
	| REGISTER_TOKEN
	{
		printDebugLog("storage_class_specifier:REGISTER_TOKEN");
        $_[1];
	}
	;

# ユーザ定義型(typedef)は、TNAME_TOKENとしている
type_specifier
	: VOID_TOKEN
	{
		printDebugLog("type_specifier:VOID_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| CHAR_TOKEN
	{
		printDebugLog("type_specifier:CHAR_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| SHORT_TOKEN
	{
		printDebugLog("type_specifier:SHORT_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| INT_TOKEN
	{
		printDebugLog("type_specifier:INT_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| LONG_TOKEN
	{
		printDebugLog("type_specifier:LONG_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| FLOAT_TOKEN
	{
		printDebugLog("type_specifier:FLOAT_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| DOUBLE_TOKEN
	{
		printDebugLog("type_specifier:DOUBLE_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| SIGNED_TOKEN
	{
		printDebugLog("type_specifier:SIGNED_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| UNSIGNED_TOKEN
	{
		printDebugLog("type_specifier:UNSIGNED_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| _BOOL_TOKEN
	{
		printDebugLog("type_specifier:_BOOL_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| _COMPLEX_TOKEN
	{
		printDebugLog("type_specifier:_COMPLEX_TOKEN");
		['N_type_specifier', $_[1] ];
	}
	| struct_or_union_specifier # 構造体・共有体情報は解析を行わない
	{
		printDebugLog("type_specifier:struct_or_union_specifier");
		undef;
	}
	| enum_specifier # ENUM情報は解析を行わない
	{
		printDebugLog("type_specifier:enum_specifier");
		undef;
	}
    | TNAME_TOKEN
    {
    	printDebugLog("type_specifier:TNAME_TOKEN");
 		['N_type_specifier', $_[1] ];
    }
	;

#! 構造体・共有体情報は解析を行わない
struct_or_union_specifier
	: struct_or_union IDENTIFIER LCB_TOKEN struct_declaration_list RCB_TOKEN
	{
		printDebugLog("struct_or_union_specifier:struct_or_union IDENTIFIER { struct_declaration_list }");
		undef;
	}
	| struct_or_union LCB_TOKEN struct_declaration_list RCB_TOKEN #! identifier のopt対処
	{
		printDebugLog("struct_or_union_specifier:struct_or_union { struct_declaration_list }");
		undef;
	}
	| struct_or_union IDENTIFIER
	{
		printDebugLog("struct_or_union_specifier:struct_or_union IDENTIFIER");
		undef;
	}
	;

struct_or_union
	: STRUCT_TOKEN
	{
		printDebugLog("struct_or_union:STRUCT_TOKEN");
		$_[1];
	}
	| UNION_TOKEN
	{
		printDebugLog("struct_or_union:UNION_TOKEN");
		$_[1];
	}
	;

#! 構造体・共有体情報は解析を行わない
struct_declaration_list
	: struct_declaration
	{
		printDebugLog("struct_declaration_list:struct_declaration");
		undef;
	}
	| struct_declaration_list struct_declaration
	{
		printDebugLog("struct_declaration_list:struct_declaration_list struct_declaration");
		undef;
	}
	;

#! 構造体・共有体情報は解析を行わない
struct_declaration
	: specifier_qualifier_list struct_declarator_list SMC_TOKEN
	{
		printDebugLog("struct_declaration:specifier_qualifier_list struct_declarator_list ;");
		undef;
	}
	;

#! 構造体・共有体情報は解析を行わない
specifier_qualifier_list
	: type_specifier specifier_qualifier_list
	{
		printDebugLog("specifier_qualifier_list:type_specifier specifier_qualifier_list");
		undef;
	}
	| type_specifier #! specifier_qualifier_list のopt対処
	{
		printDebugLog("specifier_qualifier_list:type_specifier");
		undef;
	}
	| type_qualifier specifier_qualifier_list
	{
		printDebugLog("specifier_qualifier_list:type_qualifier specifier_qualifier_list");
		undef;
	}
	| type_qualifier #! specifier_qualifier_list のopt対処
	{
		printDebugLog("specifier_qualifier_list:type_qualifier");
		undef;
	}
	;

#! 構造体・共有体情報は解析を行わない
struct_declarator_list
	: struct_declarator
	{
		printDebugLog("struct_declarator_list:struct_declarator");
		undef;
	}
	| struct_declarator_list CM_TOKEN struct_declarator
	{
		printDebugLog("struct_declarator_list:struct_declarator_list , struct_declarator");
		undef;
	}
	;

#! 構造体・共有体情報は解析を行わない
struct_declarator
	: declarator
	{
		printDebugLog("struct_declarator:declarator");
		undef;
	}
	| declarator CLN_TOKEN constant_expression
	{
		printDebugLog("struct_declarator:declarator : constant_expression");
		undef;
	}
	| CLN_TOKEN constant_expression
	{
		printDebugLog("struct_declarator: : constant_expression");
		undef;
	}
	;

#! ENUM情報は解析を行わない
enum_specifier
	: ENUM_TOKEN IDENTIFIER LCB_TOKEN enumerator_list RCB_TOKEN
	{
		printDebugLog("enum_specifier:enum IDENTIFIER { enumerator_list }");
		undef;
	}
	| ENUM_TOKEN LCB_TOKEN enumerator_list RCB_TOKEN	#! identifier のopt対処
	{
		printDebugLog("enum_specifier:enum { enumerator_list }");
		undef;
	}
	| ENUM_TOKEN IDENTIFIER LCB_TOKEN enumerator_list CM_TOKEN RCB_TOKEN
	{
		printDebugLog("enum_specifier:enum IDENTIFIER { enumerator_list , }");
		undef;
	}
	| ENUM_TOKEN LCB_TOKEN enumerator_list CM_TOKEN RCB_TOKEN	#! identifier のopt対処
	{
		printDebugLog("enum_specifier:enum { enumerator_list , }");
		undef;
	}
	| ENUM_TOKEN IDENTIFIER
	{
		printDebugLog("enum_specifier:enum IDENTIFIER");
		undef;
	}
	;

#! ENUM情報は解析を行わない
enumerator_list
	: enumerator
	{
		printDebugLog("enumerator_list:enumerator");
		undef;
	}
	| enumerator_list CM_TOKEN enumerator
	{
		printDebugLog("enumerator_list:enumerator_list , enumerator");
		undef;
	}
	;

#! ENUM情報は解析を行わない
enumerator
	: enumeration_constant
	{
		printDebugLog("enumerator:enumeration_constant");
		undef;
	}
	| enumeration_constant EQUAL_OPR constant_expression
	{
		printDebugLog("enumerator:enumeration_constant ~ constant_expression");
		undef;
	}
	;

enumeration_constant #! C99のLexerより。enumeration_constantをなくしてもいいが・・・
	: IDENTIFIER
	{
		printDebugLog("enumeration_constant:IDENTIFIER");
		$_[1];
	}
	;

type_qualifier
	: CONST_TOKEN
	{
		printDebugLog("type_qualifier:CONST_TOKEN");
		$_[1];
	}
	| RESTRICT_TOKEN
	{
		printDebugLog("type_qualifier:RESTRICT_TOKEN");
		$_[1];
	}
	| VOLATILE_TOKEN
	{
		printDebugLog("type_qualifier:VOLATILE_TOKEN");
		$_[1];
	}
	;

function_specifier
	: INLINE_TOKEN
	{
		printDebugLog("function_specifier:INLINE_TOKEN");
		$_[1];
	}
	;

declarator
	: pointer direct_declarator # ポインタ情報は格納しない
	{
		printDebugLog("declarator:pointer direct_declarator");
        $_[2];
	}
	| direct_declarator			#! pointer のopt対処
	{
		printDebugLog("declarator:direct_declarator");
		$_[1];
	}
	;

direct_declarator
	: IDENTIFIER
	{
		printDebugLog("direct_declarator:IDENTIFIER");
		[['N_MetaNode', {name => $_[1]}], $_[1] ];
	}
	| LP_TOKEN declarator RP_TOKEN
	{
		printDebugLog("direct_declarator:( declarator )");
		$_[2];
	}
	| direct_declarator LSB_TOKEN type_qualifier_list assignment_expression RSB_TOKEN	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:direct_declarator [ type_qualifier_list assignment_expression ]");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LSB_TOKEN assignment_expression RSB_TOKEN #! type_quualifier_list のopt対処	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:direct_declarator [ assignment_expression ]");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LSB_TOKEN type_qualifier_list RSB_TOKEN #! assignment_expression のopt対処	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:direct_declarator [ type_qualifier_list ]");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LSB_TOKEN RSB_TOKEN #! type_quualifier_list, assignment_expression のopt対処	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:direct_declarator[]");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LSB_TOKEN STATIC_TOKEN type_qualifier_list assignment_expression RSB_TOKEN	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:direct_declarator [ static type_qualifier_list assignment_expression ]");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LSB_TOKEN STATIC_TOKEN assignment_expression RSB_TOKEN #! type_quualifier_list のopt対処	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:direct_declarator [ static assignment_expression ]");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LSB_TOKEN type_qualifier_list STATIC_TOKEN assignment_expression RSB_TOKEN	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LSB_TOKEN type_qualifier_list ASTARI_OPR RSB_TOKEN	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:direct_declarator [ type_qualifier_list * ]");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LSB_TOKEN ASTARI_OPR RSB_TOKEN  #! type_quualifier_list のopt対処	# 配列の中身は格納しない
	{
		printDebugLog("direct_declarator:direct_declarator [ * ]");
		my $metanode = shift @{$_[1]};
        my $decl = $metanode->[1];
        $decl->{type} = 'ARRAY';
		[ $metanode , $_[1] ];
	}
	| direct_declarator LP_TOKEN parameter_type_list RP_TOKEN # 関数の引数のパラメータは解析を行わない
	{
		printDebugLog("direct_declarator:direct_declarator ( parameter_type_list )");
		[ $_[1] , [] ];
	}
	| direct_declarator LP_TOKEN identifier_list RP_TOKEN # 関数の引数のパラメータは解析を行わない
	{
		printDebugLog("direct_declarator:direct_declarator ( identifier_list )");
		[ $_[1] , [] ];
	}
	| direct_declarator LP_TOKEN RP_TOKEN #! identifier_list のopt対処
	{
		printDebugLog("direct_declarator:direct_declarator ( )");
		[ $_[1] , [] ];
	}
	;

#! ポインタ情報は格納しない
pointer
	: ASTARI_OPR type_qualifier_list	# ここでの修飾子は取得しない
	{
		printDebugLog("pointer: * type_qualifier_list");
		undef;
	}
	| ASTARI_OPR					#! type_quualifier_list のopt対処
	{
		printDebugLog("pointer: * ");
		undef;
	}
	| ASTARI_OPR type_qualifier_list pointer	# ここでの修飾子は取得しない
	{
		printDebugLog("pointer: * type_qualifier_list pointer");
		undef;
	}
	| ASTARI_OPR pointer			#! type_quualifier_list のopt対処
	{
		printDebugLog("pointer: * pointer");
		undef;
	}
	;

#! ポインタ情報、配列の中身は格納しない
type_qualifier_list
	: type_qualifier
	{
		printDebugLog("type_qualifier_list:type_qualifier");
		undef;
	}
	| type_qualifier_list type_qualifier
	{
		printDebugLog("type_qualifier_list:type_qualifier_list type_qualifier");
		undef;
	}
	;

#! 関数の引数のパラメータは解析を行わない
parameter_type_list
	: parameter_list
	{
		printDebugLog("parameter_type_list:parameter_list");
		undef;
	}
	| parameter_list CM_TOKEN ELLIPSIS_TOKEN
	{
		printDebugLog("parameter_type_list:parameter_list , ...");
		undef;
	}
	;

#! 関数の引数のパラメータは解析を行わない
parameter_list
	: parameter_declaration
	{
		printDebugLog("parameter_list:parameter_declaration");
		undef;
	}
	| parameter_list CM_TOKEN parameter_declaration
	{
		printDebugLog("parameter_list:parameter_list , parameter_declaration");
		undef;
	}
	;

#! 関数の引数のパラメータは解析を行わない
parameter_declaration
	: declaration_specifiers declarator
	{
		printDebugLog("parameter_declaration:declaration_specifiers declarator");
		undef;
	}
	| declaration_specifiers abstract_declarator
	{
		printDebugLog("parameter_declaration:declaration_specifiers abstract_declarator");
		undef;
	}
	| declaration_specifiers  #! abstract_declarator のopt対処
	{
		printDebugLog("parameter_declaration:declaration_specifiers");
		undef;
	}
	;

#! 関数の引数のパラメータは解析を行わない
identifier_list
	: IDENTIFIER
	{
		printDebugLog("identifier_list:IDENTIFIER");
		undef;
	}
	| identifier_list CM_TOKEN IDENTIFIER
	{
		printDebugLog("identifier_list:identifier_list , IDENTIFIER");
		undef;
	}
	;

#! キャスト情報・単項演算子（sizeof演算子）・例：(const float[]){1,2,} は解析を行わない
type_name
	: specifier_qualifier_list abstract_declarator
	{
		printDebugLog("type_name:speficier_qualifier_list abstract_declarator");
		undef;
	}
	| specifier_qualifier_list #! abstract_declarator のopt対処
	{
		printDebugLog("type_name:speficier_qualifier_list");
		undef;
	}
	;

#! 関数の引数のパラメータ・キャスト情報・単項演算子（sizeof演算子）・例：(const float[]){1,2,} は解析を行わない
abstract_declarator
	: pointer
	{
		printDebugLog("abstract_declarator:pointer");
		undef;
	}
	| pointer direct_abstract_declarator
	{
		printDebugLog("abstract_declarator:pointer direct_abstract_declarator");
		undef;
	}
	| direct_abstract_declarator #! pointer のopt対処
	{
		printDebugLog("abstract_declarator:direct_abstract_declarator");
		undef;
	}
	;

#! 関数の引数のパラメータ・キャスト情報・単項演算子（sizeof演算子）・例：(const float[]){1,2,} は解析を行わない
direct_abstract_declarator
	: LP_TOKEN abstract_declarator RP_TOKEN
	{
		printDebugLog("direct_abstract_declarator: ( abstract_declarator )");
		undef;
	}
	| LSB_TOKEN RSB_TOKEN #! direct_abstract_declarator, assignment_expression のopt対処
	{
		printDebugLog("direct_abstract_declarator: [ ]");
		undef;
	}
	| direct_abstract_declarator LSB_TOKEN RSB_TOKEN #! assignment_expression のopt対処
	{
		printDebugLog("direct_abstract_declarator: direct_abstract_declarator [ ]");
		undef;
	}
	| LSB_TOKEN assignment_expression RSB_TOKEN #! direct_abstract_declarator のopt対処
	{
		printDebugLog("direct_abstract_declarator: [ assignment_expression ]");
		undef;
	}
	| direct_abstract_declarator LSB_TOKEN assignment_expression RSB_TOKEN
	{
		printDebugLog("direct_abstract_declarator: direct_abstract_declarator [ assignment_expression ]");
		undef;
	}
	| direct_abstract_declarator LSB_TOKEN ASTARI_OPR RSB_TOKEN
	{
		printDebugLog("direct_abstract_declarator: direct_abstract_declarator [ * ]");
		undef;
	}
	| LSB_TOKEN ASTARI_OPR RSB_TOKEN #! direct_abstract_declarator のopt対処
	{
		printDebugLog("direct_abstract_declarator: [ * ]");
		undef;
	}
	| LP_TOKEN RP_TOKEN #! direct_abstract_declarator, parameter_type_list のopt対処
	{
		printDebugLog("direct_abstract_declarator: ( )");
		undef;
	}
	| LP_TOKEN parameter_type_list RP_TOKEN #! direct_abstract_declarator のopt対処
	{
		printDebugLog("direct_abstract_declarator: ( parameter_type_list )");
		undef;
	}
	| direct_abstract_declarator LP_TOKEN RP_TOKEN #! parameter_type_list のopt対処
	{
		printDebugLog("direct_abstract_declarator: direct_abstract_declarator ( )");
		undef;
	}
	| direct_abstract_declarator LP_TOKEN parameter_type_list RP_TOKEN
	{
		printDebugLog("direct_abstract_declarator: direct_abstract_declarator ( parameter_type_list )");
		undef;
	}
	;

initializer
	: assignment_expression
	{
		printDebugLog("initializer:assignment_expression");
		$_[1];
	}
	| LCB_TOKEN initializer_list RCB_TOKEN
	{	
		printDebugLog("initializer:{ initializer_list }");
        defined $_[2] ? ['N_ScopeInfo', create_scopeinfo($_[2])] : undef
	}
	| LCB_TOKEN initializer_list CM_TOKEN RCB_TOKEN
	{
		printDebugLog("initializer:{ initializer_list , }");
		defined $_[2] ? ['N_ScopeInfo', create_scopeinfo($_[2])] : undef
	}
	;

initializer_list
	: designation initializer # 構造体のメンバ・配列の要素への初期化は解析しない
	{
		printDebugLog("initializer_list:designation initializer");
		undef;
	}
	| initializer #! designation のopt対処
	{
		printDebugLog("initializer_list:initializer");
		['N_initializer_list', $_[1]];
	}
	| initializer_list CM_TOKEN designation initializer # 構造体のメンバ・配列の要素への初期化は解析しない
	{
		printDebugLog("initializer_list:initializer_list , designation initializer");
		undef;
	}
	| initializer_list CM_TOKEN initializer #! designation のopt対処
	{
		printDebugLog("initializer_list:initializer_list , initializer");
        push(@{$_[1]}, $_[2], $_[3]);
        $_[1];
	}
	;

#! 構造体のメンバ・配列の要素への初期化は解析しない
designation
	: designator_list EQUAL_OPR
	{
		printDebugLog("designation:designator_list =");
		undef;
	}
	;

#! 構造体のメンバ・配列の要素への初期化は解析しない
designator_list
	: designator
	{
		printDebugLog("designator_list:designator");
		undef;
	}
	| designator_list designator
	{
		printDebugLog("designator_list:designator_list designator");
		undef;
	}
	;

#! 構造体のメンバ・配列の要素への初期化は解析しない
designator
	: LSB_TOKEN constant_expression RSB_TOKEN
	{
		printDebugLog("designator: [ constant_expression ]");
		undef;
	}
	| DOT_TOKEN IDENTIFIER
	{
		printDebugLog("designator: . IDENTIFIER");
		undef;
	}
	;


# A.2.3 Statements
statement
	: labeled_statement
	{
		printDebugLog("statement:labeled_statement");
		$_[1];
	}
	| compound_statement
	{
		printDebugLog("statement:compound_statement");
		$_[1];
	}
	| expression_statement
	{
		printDebugLog("statement:expression_statement");
		$_[1];
	}
	| selection_statement
	{
		printDebugLog("statement:selection_statement");
		$_[1];
	}
	| iteration_statement
	{
		printDebugLog("statement:iteration_statement");
		$_[1];
	}
	| jump_statement
	{
		printDebugLog("statement:jump_statement");
		$_[1];
	}
	| embedded_sql #! Embedded SQLを追加
	{
		printDebugLog("statement:embedded_sql");
		$_[1];
	}
	;

labeled_statement
	: IDENTIFIER CLN_TOKEN statement
	{
		printDebugLog("labeled_statment: IDENTIFIER : statement");
        $_[3];
	}
	| CASE_TOKEN constant_expression CLN_TOKEN statement
	{
		printDebugLog("labeled_statment: case constant_expression : statement");

		if(defined $_[4]){
			shift @{$_[4]};
        	my $first_block_stmt = shift @{$_[4]};
        	[ 'stmt', [ 'N_SwitchLabel', create_linenode($_[1]),  $first_block_stmt ], @{$_[4]} ];
		} 
		else{
			['line', create_linenode($_[1])];
		}
	}
	| DEFAULT_TOKEN CLN_TOKEN statement
	{
		printDebugLog("labeled_statment: default : statement");
		if(defined $_[3]){
			shift @{$_[3]};
        	my $first_block_stmt = shift @{$_[3]};
        	[ 'stmt', [ 'N_SwitchLabel', create_linenode($_[1]),  $first_block_stmt ], @{$_[3]} ];
		} 
		else{
			['line', create_linenode($_[1])];
		}
	}
	;

compound_statement
	: LCB_TOKEN RCB_TOKEN #! block_item_list のopt対処
	{
		printDebugLog("compound_statement: { }");
		[ 'N_ScopeInfo' , create_scopeinfo(['N_block_item_list'])];
	}
	| LCB_TOKEN block_item_list RCB_TOKEN
	{
		printDebugLog("compound_statement: { block_item_list }");
		[ 'N_ScopeInfo' , create_scopeinfo($_[2])];
	}
	;

block_item_list
	: block_item
	{
		printDebugLog("block_item_list:block_item");
        my $blockitemlist = ['N_block_item_list'];
        defined $_[1] and push(@{$blockitemlist}, $_[1]);
        $blockitemlist;
	}
	| block_item_list block_item
	{
		printDebugLog("block_item_list:block_item_list block_item");
        defined $_[2] and push(@{$_[1]}, $_[2]);
        $_[1];
	}
	;

#! 関数内に記述された埋め込みSQLを解析するルールはココに記述する
block_item
	: declaration
	{
		printDebugLog("block_item:declaration");
        
        my $memberdecl = $_[1];
		
		if(exists($memberdecl->{VARIABLE})) {
			
			my $type         = $memberdecl->{VARIABLE}->[0];
       		my $variabledecl = $memberdecl->{VARIABLE}->[1];
            
            my @varlist = ();
            for my $current_vardecl (@{$variabledecl}) {
            
                my $decl = refer_metanode($current_vardecl);
                
                if(defined $decl) {
 		            my $varinfo = create_VariableInfo($decl->{name}, $type, $decl->{type}, $decl->{value});
                    push(@varlist, $varinfo);
                }
            }
            undef $memberdecl->{VARIABLE};
            $memberdecl->{VARIABLE} = \@varlist;
            $memberdecl;

        }
		else{
			undef;
		}
		
	}
	| statement
	{
		printDebugLog("block_item:statement");
		$_[1];
	}
	;

expression_statement
	: expression SMC_TOKEN
	{
		printDebugLog("expression_statement: expression ;");
		$_[1];
	}
	| SMC_TOKEN #! expression のopt対処
	{
		printDebugLog("expression_statement: ;");
		undef;
	}
	;

selection_statement
	: IF_TOKEN LP_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("selection_statement: if ( expression ) statement");
		 ['N_if', create_linenode($_[1]),  ['N_ParExpression', $_[3]], ['N_Delimiter'], $_[5]];
	}
	| IF_TOKEN LP_TOKEN expression RP_TOKEN statement ELSE_TOKEN statement
	{
		printDebugLog("selection_statement: if ( expression ) statement else statement");
		 ['N_if', create_linenode($_[1]), ['N_ParExpression', $_[3]] , ['N_Delimiter'], $_[5], ['N_Delimiter'], ['N_else', create_addcode(), create_linenode($_[6]), $_[7]]];
	}
	| SWITCH_TOKEN LP_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("selection_statement: switch ( expression ) statement");
		 ['N_switch',  create_linenode($_[1]), ['N_ParExpression', $_[3]] , $_[5]];
	}
	;

#! forのexpression指定のバリエーションを展開
iteration_statement
	: WHILE_TOKEN LP_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("iteration_statement: while ( expression ) statement");
		['N_while', create_linenode($_[1]), ['N_ParExpression', $_[3]] , ['N_Delimiter'], $_[5]];
	}
	| DO_TOKEN statement WHILE_TOKEN LP_TOKEN expression RP_TOKEN SMC_TOKEN
	{
		printDebugLog("iteration_statement: do statement while ( expression ) ;");
		['N_while', create_linenode($_[1]), $_[2], ['N_Delimiter'], create_addcode(), create_linenode($_[3]), ['N_ParExpression', $_[5]]];
	}
	| FOR_TOKEN LP_TOKEN            SMC_TOKEN            SMC_TOKEN            RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( ; ; ) statement");
        ['N_for', create_linenode($_[1]),  undef, ['N_Delimiter'], $_[6]];
	}
	| FOR_TOKEN LP_TOKEN expression SMC_TOKEN            SMC_TOKEN            RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( expression ; ; ) statement");
        my @result_forcontrol = ('N_ForControl');
        my @result_forinit = ('N_ForInit');
        defined $_[3] and do { push(@result_forinit, $_[3]);  };
        defined $_[3] and do { push(@result_forcontrol, \@result_forinit);  };
        ['N_for', create_linenode($_[1]), \@result_forcontrol , ['N_Delimiter'], $_[7]];
	}
	| FOR_TOKEN LP_TOKEN            SMC_TOKEN expression SMC_TOKEN            RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( ; expression ; ) statement");
        my @result_forcontrol = ('N_ForControl');
        defined $_[4] and do { push(@result_forcontrol, create_addcode()); push(@result_forcontrol, $_[4]);  };
        ['N_for', create_linenode($_[1]), \@result_forcontrol , ['N_Delimiter'], $_[7]];
	}
	| FOR_TOKEN LP_TOKEN            SMC_TOKEN            SMC_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( ; ; expression ) statement");
        my @result_forcontrol = ('N_ForControl');
        my @result_forupdate = ('N_ForUpdate');
        defined $_[5] and do { push(@result_forupdate, $_[5]);  };
        defined $_[5] and do { push(@result_forcontrol, create_addcode()); push(@result_forcontrol, \@result_forupdate);  };
        ['N_for', create_linenode($_[1]), \@result_forcontrol , ['N_Delimiter'], $_[7]];
	}
	| FOR_TOKEN LP_TOKEN            SMC_TOKEN expression SMC_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( ; expression ; expression ) statement");
        my @result_forcontrol = ('N_ForControl');
        my @result_forupdate = ('N_ForUpdate');
        defined $_[6] and do { push(@result_forupdate, $_[6]);  };
        defined $_[4] and do { push(@result_forcontrol, create_addcode()); push(@result_forcontrol, $_[4]);  };
        defined $_[6] and do { push(@result_forcontrol, create_addcode()); push(@result_forcontrol, \@result_forupdate);  };
        ['N_for', create_linenode($_[1]), \@result_forcontrol , ['N_Delimiter'], $_[8]];
	}
	| FOR_TOKEN LP_TOKEN expression SMC_TOKEN            SMC_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( expression ; ; expression ) statement");
        my @result_forcontrol = ('N_ForControl');
        my @result_forinit = ('N_ForInit');
        my @result_forupdate = ('N_ForUpdate');
        defined $_[3] and do { push(@result_forinit, $_[3]);  };
        defined $_[6] and do { push(@result_forupdate, $_[6]);  };
        defined $_[3] and do { push(@result_forcontrol, \@result_forinit);  };
        defined $_[6] and do { push(@result_forcontrol, create_addcode()); push(@result_forcontrol, \@result_forupdate);  };
        ['N_for', create_linenode($_[1]), \@result_forcontrol , ['N_Delimiter'], $_[8]];
	}
	| FOR_TOKEN LP_TOKEN expression SMC_TOKEN expression SMC_TOKEN            RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( expression ; expression ; ) statement");
        my @result_forcontrol = ('N_ForControl');
        my @result_forinit = ('N_ForInit');
        defined $_[3] and do { push(@result_forinit, $_[3]);  };
        defined $_[3] and do { push(@result_forcontrol, \@result_forinit);  };
        defined $_[5] and do { push(@result_forcontrol, create_addcode()); push(@result_forcontrol, $_[5]);  };
        ['N_for', create_linenode($_[1]), \@result_forcontrol , ['N_Delimiter'], $_[8]];
	}
	| FOR_TOKEN LP_TOKEN expression SMC_TOKEN expression SMC_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( expression ; expression ; expression ) statement");
        my @result_forcontrol = ('N_ForControl');
        my @result_forinit = ('N_ForInit');
        my @result_forupdate = ('N_ForUpdate');
        defined $_[3] and do { push(@result_forinit, $_[3]);  };
        defined $_[7] and do { push(@result_forupdate, $_[7]);  };
        defined $_[3] and do { push(@result_forcontrol, \@result_forinit);  };
        defined $_[5] and do { push(@result_forcontrol, create_addcode()); push(@result_forcontrol, $_[5]);  };
        defined $_[7] and do { push(@result_forcontrol, create_addcode()); push(@result_forcontrol, \@result_forupdate);  };
        ['N_for', create_linenode($_[1]), \@result_forcontrol , ['N_Delimiter'], $_[9]];
	}
	| FOR_TOKEN LP_TOKEN declaration expression SMC_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( declaration expression ; expression ) statement");
        my @result_forupdate = ('N_ForUpdate');
        my $result_forvar = undef;
        
        defined $_[6] and do { push(@result_forupdate, $_[6]);  };
        
        if(defined $_[3]->{VARIABLE}){
        	my $result_forvar_1 = $_[3]->{VARIABLE}->[0];
        	my $result_forvar_2 = [ 'N_NormalFor' , $_[3]->{VARIABLE}->[1] , $_[4] , \@result_forupdate ];
        	$result_forvar = create_forvar_control($result_forvar_1, $result_forvar_2);
        }
        
        ['N_for' , create_linenode($_[1]), $result_forvar , ['N_Delimiter'], $_[8]];
	}
	| FOR_TOKEN LP_TOKEN declaration            SMC_TOKEN expression RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( declaration ; expression ) statement");
        my @result_forupdate = ('N_ForUpdate');
        my $result_forvar = undef;
        
        defined $_[5] and do { push(@result_forupdate, $_[5]);  };
        
        if(defined $_[3]->{VARIABLE}){
        	my $result_forvar_1 = $_[3]->{VARIABLE}->[0];
        	my $result_forvar_2 = [ 'N_NormalFor' , $_[3]->{VARIABLE}->[1] , undef , \@result_forupdate ];
        	$result_forvar = create_forvar_control($result_forvar_1, $result_forvar_2);
        }
        
        ['N_for' , create_linenode($_[1]), $result_forvar , ['N_Delimiter'], $_[7]];
	}
	| FOR_TOKEN LP_TOKEN declaration expression SMC_TOKEN            RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( declaration expression ; ) statement");
        my $result_forvar = undef;
        
        if(defined $_[3]->{VARIABLE}){
        	my $result_forvar_1 = $_[3]->{VARIABLE}->[0];
        	my $result_forvar_2 = [ 'N_NormalFor' , $_[3]->{VARIABLE}->[1] , $_[4] , undef ];
        	$result_forvar = create_forvar_control($result_forvar_1, $result_forvar_2);
        }
        
        ['N_for' , create_linenode($_[1]), $result_forvar , ['N_Delimiter'], $_[7]];
	}
	| FOR_TOKEN LP_TOKEN declaration            SMC_TOKEN            RP_TOKEN statement
	{
		printDebugLog("iteration_statement: for ( declaration ; ) statement");
        my $result_forvar = undef;
        
        if(defined $_[3]->{VARIABLE}){
        	my $result_forvar_1 = $_[3]->{VARIABLE}->[0];
        	my $result_forvar_2 = [ 'N_NormalFor' , $_[3]->{VARIABLE}->[1] , undef , undef ];
        	$result_forvar = create_forvar_control($result_forvar_1, $result_forvar_2);
        }
        
        ['N_for' , create_linenode($_[1]), $result_forvar , ['N_Delimiter'], $_[7]];
	}
	;

jump_statement
	: GOTO_TOKEN IDENTIFIER SMC_TOKEN
	{
		printDebugLog("jump_statement: goto IDENTIFIER ;");
		undef;
	}
	| CONTINUE_TOKEN SMC_TOKEN
	{
		printDebugLog("jump_statement: continue ;");
		undef;
	}
	| BREAK_TOKEN SMC_TOKEN
	{
		printDebugLog("jump_statement: break ;");
		undef;
	}
	| RETURN_TOKEN expression SMC_TOKEN
	{
		printDebugLog("jump_statement: return expression ;");
		['N_return',  create_linenode($_[1]), $_[2]];
	}
	| RETURN_TOKEN SMC_TOKEN #! expression のopt対処
	{
		printDebugLog("jump_statement: return ;");
		undef;
	}
	;


# A.2.4 External definitions
translation_unit:
#    /* empty */
	| external_declaration
	{
		printDebugLog("translation_unit:external_declaration");
		if(defined $_[1]) {
            if(ref($_[1]) eq "HASH" && exists($_[1]->{VARIABLE})) {
                $G_fileinfo_ref->varlist($_[1]->{VARIABLE});
            }
    		if(ref($_[1]) eq "HASH" && exists($_[1]->{FUNCTION})) {
            	push(@{$G_fileinfo_ref->functionlist()}, $_[1]->{FUNCTION});
            }
        }
        $G_fileinfo_ref
	}
	| translation_unit external_declaration
	{
		printDebugLog("translation_unit:translation_unit external_declaration");
		if(defined $_[2]) {
            if(ref($_[2]) eq "HASH" && exists($_[2]->{VARIABLE})) {
                push(@{$G_fileinfo_ref->varlist()}, @{$_[2]->{VARIABLE}});
            }
    		if(ref($_[2]) eq "HASH" && exists($_[2]->{FUNCTION})) {
            	push(@{$G_fileinfo_ref->functionlist()}, $_[2]->{FUNCTION});
            }
        }
        $G_fileinfo_ref
	}
	;

#! グローバル領域に記述できないものもあるが、とりあえず埋め込みSQL
#! 関連はすべてグローバル領域に記述できるようなルールとする
external_declaration
	: function_definition
	{
		printDebugLog("external_declaration:function_definition");
		if(defined $_[1]) {
            $_[1];
        }else{
            undef;
        }
	}
	| declaration
	{
		printDebugLog("external_declaration:declaration");

		my $memberdecl = $_[1];
		
		if(ref($memberdecl) eq "HASH" && exists($memberdecl->{VARIABLE})) {
			
			my $type         = $memberdecl->{VARIABLE}->[0];
       		my $variabledecl = $memberdecl->{VARIABLE}->[1];
            
            my @varlist = ();
            for my $current_vardecl (@{$variabledecl}) {
            
                my $decl = refer_metanode($current_vardecl);
                
                if(defined $decl) {
 		            my $varinfo = create_VariableInfo($decl->{name}, $type, $decl->{type}, $decl->{value});
                    push(@varlist, $varinfo);
                }
            }
            undef $memberdecl->{VARIABLE};
            $memberdecl->{VARIABLE} = \@varlist;
            $memberdecl;
            
        }
        else{
			undef;
		}
        
	}
	| embedded_sql #! Embedded SQLを追加
	{
		printDebugLog("external_declaration:embedded_sql");
		$_[1];
	}
	;

function_definition
	: declaration_specifiers declarator compound_statement #! declaration_list のopt対処
	{
		printDebugLog("function_definition:declaration_specifiers declarator compund_statement");
		my $method_decl = {TYPELIST => $_[2]->[1] , FUNCTIONNAME => $_[2]->[0]->[0]->[1]->{name}->{TOKEN}};
        $method_decl->{SCOPE} = $_[3];
		my $result = create_functioninfo($method_decl->{FUNCTIONNAME}, $method_decl->{SCOPE});
        if (defined $result){
            {FUNCTION => $result};
        }else{
            undef;
        }
	}
	| declaration_specifiers declarator declaration_list compound_statement # 関数の引数のパラメータは解析を行わない
	{
		printDebugLog("function_definition:declaration_specifiers declarator declaration_list compund_statement");
		my $method_decl = {TYPELIST => $_[2]->[1] , FUNCTIONNAME => $_[2]->[0]->[0]->[1]->{name}->{TOKEN}};
        $method_decl->{SCOPE} = $_[4];
		my $result = create_functioninfo($method_decl->{FUNCTIONNAME}, $method_decl->{SCOPE});
        if (defined $result){
            {FUNCTION => $result};
        }else{
            undef;
        }
	}
	;

#! 関数の引数のパラメータは解析を行わない
declaration_list
	: declaration
	{
		printDebugLog("declaration_list:declaration");
		undef;
	}
	| declaration_list declaration
	{
		printDebugLog("declaration_list:declaration_list declaration");
		undef;
	}
	;

#! DECLAREだけ1つの文字列にまとめる処理を埋め込み済み
embedded_sql
	: EXEC_TOKEN SQL_TOKEN emb_declare SMC_TOKEN
	{
		printDebugLog("embedded_sql:EXEC SQL emb_declare ;");
		undef;
	}
	| EXEC_TOKEN SQL_TOKEN emb_string_list SMC_TOKEN
	{
		printDebugLog("embedded_sql:EXEC SQL emb_string_list ;");
		my @result;
		push( @result , $_[1]);
		push( @result , $_[2]);
		push( @result , $_[3]);
		push( @result , $_[4]);
		\@result;
	}
	| EXEC_TOKEN ORACLE_TOKEN emb_string_list SMC_TOKEN
	{
		printDebugLog("embedded_sql:EXEC ORACLE emb_string_list ;");
		undef;
	}
	| EXEC_TOKEN TOOLS_TOKEN emb_string_list SMC_TOKEN
	{
		printDebugLog("embedded_sql:EXEC TOOLS emb_string_list ;");
		undef;
	}
	;

emb_declare
	: BEGIN_TOKEN DECLARE_TOKEN SECTION_TOKEN
	{
        $G_declaresection_flg=1;#ホスト宣言内のフラグを真に
		printDebugLog("emb_declare:BEGIN DECLARE SECTION");
		undef;
	}
	| END_TOKEN DECLARE_TOKEN SECTION_TOKEN
	{
        $G_declaresection_flg=0;#ホスト宣言内のフラグを偽に
		printDebugLog("emb_declare:END DECLARE SECTION");
		undef;
	}
	;

emb_string_list
	: emb_constant_string
	{
		printDebugLog("emb_string_list:emb_constant_string");
        my $current_line;
        if( ref($_[1]) eq "HASH" ){
            $current_line=$_[1]->{LINE};
        }else{
            $current_line=$_[1]-[1]->{LINE};
        }
		if( $G_ansi_comment_line == $current_line ){
            undef;
        }else{
            [ $_[1] ];
        }
	}
	| emb_string_list emb_constant_string
	{
		printDebugLog("emb_string_list:emb_string_list emb_constant_string");
        my $current_line;
        if( ref($_[2]) eq "HASH" ){
            $current_line=$_[2]->{LINE};
        }else{
            $current_line=$_[2]->[1]->{LINE};
        }
		if( $G_ansi_comment_line == $current_line ){
    		$_[1];
        }else{
    		push( @{$_[1]} , $_[2]);
    		$_[1];
        }
	}
	;

#! TOKENとしてひっかるもの(breakなど)も通すようにする必要がある
#! が、今はそこまで記述していない
#! これは、WHENEVERで指定されるもの、カラム名、テーブル名など小文字
#! で記述されたものが引っかかる・・・
emb_constant_string
	: IDENTIFIER_ORG
	{
		printDebugLog("emb_constant_string:IDENTIFIER_ORG");
		 $_[1];
	}
	| FLOAT_LITERAL
	{
		printDebugLog("emb_constant_string:FLOAT_LITERAL");
		 $_[1];
	}
	| INTEGER_LITERAL
	{
		printDebugLog("emb_constant_string:INTEGER_LITERAL");
		 $_[1];
	}
	| CHAR_LITERAL
	{
		printDebugLog("emb_constant_string:CHAR_LITERAL");
		 $_[1];
	}
	| STRING_LITERAL
	{
		printDebugLog("emb_constant_string:STRING_LITERAL");
		 $_[1];
	}
	| CLN_TOKEN IDENTIFIER_ORG #! ホスト変数
	{
		printDebugLog("emb_constant_string: : IDENTIFIER_ORG");
		[ $_[1] , $_[2] ];
	}
	| DECLARE_TOKEN
	{
		printDebugLog("emb_constant_string:DECLARE");
		 $_[1];
	}
	| DO_TOKEN
	{
		printDebugLog("emb_constant_string:do");
		 $_[1];
	}
	| BREAK_TOKEN
	{
		printDebugLog("emb_constant_string:break");
		 $_[1];
	}
	| CONTINUE_TOKEN
	{
		printDebugLog("emb_constant_string:continue");
		 $_[1];
	}
	| GOTO_TOKEN
	{
		printDebugLog("emb_constant_string:goto");
		 $_[1];
	}
	| unary_operator
	{
		printDebugLog("emb_constant_string:unary_operator:&,*,+,-,!~");
		$_[1];
	}
	| EQUAL_OPR	#! 便宜上、オペレータは適当に追加
	{
		printDebugLog("emb_constant_string:=");
		 $_[1];
	}
	| LP_TOKEN
	{
		printDebugLog("emb_constant_string:(");
		 $_[1];
	}
	| RP_TOKEN
	{
		printDebugLog("emb_constant_string:)");
		 $_[1];
	}
	| SMC_TOKEN
	{
		printDebugLog("emb_constant_string:;");
		 $_[1];
	}
	| CM_TOKEN
	{
		printDebugLog("emb_constant_string:,");
		 $_[1];
	}
	| DOT_TOKEN
	{
		printDebugLog("emb_constant_string:.");
		 $_[1];
	}
	| QUES_TOKEN
	{
		printDebugLog("emb_constant_string:?");
		 $_[1];
	}
	| GT_OPR
	{
		printDebugLog("emb_constant_string:>");
		 $_[1];
	}
	| LT_OPR
	{
		printDebugLog("emb_constant_string:<");
		 $_[1];
	}
	| RELATIONAL_OPR
	{
		printDebugLog("emb_constant_string:[<>]=");
		 $_[1];
	}
	| _BOOL_TOKEN
	{
		printDebugLog("emb_constant_string:_Bool");
		 $_[1];
	}
	| _COMPLEX_TOKEN
	{
		printDebugLog("emb_constant_string:_Complex");
		 $_[1];
	}
	| _IMAGINARY_TOKEN
	{
		printDebugLog("emb_constant_string:_Imaginary");
		 $_[1];
	}
	| AUTO_TOKEN
	{
		printDebugLog("emb_constant_string:auto");
		 $_[1];
	}
	| CASE_TOKEN
	{
		printDebugLog("emb_constant_string:case");
		 $_[1];
	}
	| CHAR_TOKEN
	{
		printDebugLog("emb_constant_string:char");
		 $_[1];
	}
	| CONST_TOKEN
	{
		printDebugLog("emb_constant_string:const");
		 $_[1];
	}
	| DEFAULT_TOKEN
	{
		printDebugLog("emb_constant_string:default");
		 $_[1];
	}
	| DOUBLE_TOKEN
	{
		printDebugLog("emb_constant_string:double");
		 $_[1];
	}
	| ELSE_TOKEN
	{
		printDebugLog("emb_constant_string:else");
		 $_[1];
	}
	| ENUM_TOKEN
	{
		printDebugLog("emb_constant_string:enum");
		 $_[1];
	}
	| EXTERN_TOKEN
	{
		printDebugLog("emb_constant_string:extern");
		 $_[1];
	}
	| FLOAT_TOKEN
	{
		printDebugLog("emb_constant_string:float");
		 $_[1];
	}
	| FOR_TOKEN
	{
		printDebugLog("emb_constant_string:for");
		 $_[1];
	}
	| IF_TOKEN
	{
		printDebugLog("emb_constant_string:if");
		 $_[1];
	}
	| INLINE_TOKEN
	{
		printDebugLog("emb_constant_string:inline");
		 $_[1];
	}
	| INT_TOKEN
	{
		printDebugLog("emb_constant_string:int");
		 $_[1];
	}
	| LONG_TOKEN
	{
		printDebugLog("emb_constant_string:long");
		 $_[1];
	}
	| NEW_TOKEN
	{
		printDebugLog("emb_constant_string:new");
		 $_[1];
	}
	| PRIVATE_TOKEN
	{
		printDebugLog("emb_constant_string:private");
		 $_[1];
	}
	| PROTECTED_TOKEN
	{
		printDebugLog("emb_constant_string:protected");
		 $_[1];
	}
	| PUBLIC_TOKEN
	{
		printDebugLog("emb_constant_string:public");
		 $_[1];
	}
	| REGISTER_TOKEN
	{
		printDebugLog("emb_constant_string:register");
		 $_[1];
	}
	| RESTRICT_TOKEN
	{
		printDebugLog("emb_constant_string:restrict");
		 $_[1];
	}
	| RETURN_TOKEN
	{
		printDebugLog("emb_constant_string:return");
		 $_[1];
	}
	| SHORT_TOKEN
	{
		printDebugLog("emb_constant_string:short");
		 $_[1];
	}
	| SIGNED_TOKEN
	{
		printDebugLog("emb_constant_string:signed");
		 $_[1];
	}
	| SIZEOF_TOKEN
	{
		printDebugLog("emb_constant_string:sizeof");
		 $_[1];
	}
	| STATIC_TOKEN
	{
		printDebugLog("emb_constant_string:static");
		 $_[1];
	}
	| STRUCT_TOKEN
	{
		printDebugLog("emb_constant_string:struct");
		 $_[1];
	}
	| SWITCH_TOKEN
	{
		printDebugLog("emb_constant_string:switch");
		 $_[1];
	}
	| TYPEDEF_TOKEN
	{
		printDebugLog("emb_constant_string:typedef");
		 $_[1];
	}
	| UNION_TOKEN
	{
		printDebugLog("emb_constant_string:union");
		 $_[1];
	}
	| UNSIGNED_TOKEN
	{
		printDebugLog("emb_constant_string:unsigned");
		 $_[1];
	}
	| VOLATILE_TOKEN
	{
		printDebugLog("emb_constant_string:volatile");
		 $_[1];
	}
	| VOID_TOKEN
	{
		printDebugLog("emb_constant_string:void");
		 $_[1];
	}
	| WHILE_TOKEN
	{
		printDebugLog("emb_constant_string:while");
		 $_[1];
	}
	| BEGIN_TOKEN
	{
		printDebugLog("emb_constant_string:begin");
		 $_[1];
	}
	| END_TOKEN
	{
		printDebugLog("emb_constant_string:end");
		 $_[1];
	}
	| ATMARK_TOKEN
	{
		printDebugLog("emb_constant_string:@");
		 $_[1];
	}
	| TNAME_TOKEN
	{
		printDebugLog("emb_constant_string:TNAME_TOKEN");
		 $_[1];
	}
	| POSTFIX_OPR
	{
		printDebugLog("emb_constant_string:(++|--)");
		$G_ansi_comment_line=$_[1]->{LINE};
        $_[1];
	}
	| EQUALITY_OPR
	{
		printDebugLog("emb_constant_string:[!|=]=");
        $_[1];
	}
	| ASSIGN_OPR
	{
		printDebugLog("emb_constant_string:(! *=,/=,%=,-=,<<=,>>=,&=,^=,|=)");
        $_[1];
	}
	| COR_OPR
	{
		printDebugLog("emb_constant_string:||");
        $_[1];
	}
	| INEQUALITY_OPR
	{
		printDebugLog("emb_constant_string:<>");
        $_[1];
	}
	| LSB_TOKEN
	{
		printDebugLog("emb_constant_string:[");
        $_[1];
	}
	| RSB_TOKEN
	{
		printDebugLog("emb_constant_string:]");
        $_[1];
	}
	| MULTI_OPR
	{
		printDebugLog("emb_constant_string:/");
        $_[1];
	}
	| EXEC_TOKEN
	{
		printDebugLog("emb_constant_string:exec");
		 $_[1];
	}
	| PTR_OPR
	{
		printDebugLog("emb_constant_string:->");
		 $_[1];
	}
	;

IDENTIFIER
    : IDENTIFIER_ORG
    | EXEC_TOKEN
    | SQL_TOKEN
    | ORACLE_TOKEN
    | TOOLS_TOKEN
    | BEGIN_TOKEN
    | END_TOKEN
    | DECLARE_TOKEN
    | SECTION_TOKEN
    ;
%%

#####################################################################
# Function: _Error
#
# 概要:
# 構文エラーの起因となったトークンと行番号を埋め込んだ文字列を生成
# する。
# 構文エラーを検出した際に実行される。
#
# パラメータ:
# _[0] - パーサオブジェクト
#
# 戻り値:
# なし
#
# 例外:
# なし
#
# 特記事項:
# - 文字列のフォーマットを下記とする。
# Parse error %s:行番号 (エラーの原因となった字句)\n
#
#####################################################################
sub _Error {
	my $curval = $_[0]->YYCurval;
    if(!defined $curval->{LINE}) {
        $curval->{LINE}=0;
    }
    if(!defined $curval->{TOKEN}) {
        $curval->{TOKEN}="";
    }
	$_[0]->{YYData}->{ERRMES} = sprintf "Parse error %%s:%d (near token '%s')\n", $curval->{LINE}, $curval->{TOKEN};
}

#####################################################################
# Function: _Lexer
#
# 概要:
# 字句解析を実行し、1トークンの情報を返却する。パーサオブジェクトにより
# 実行される。
#
# パラメータ:
# parser - パーサオブジェクト
#
# 戻り値:
# - トークンIDとトークン情報のリスト
#
# 例外:
# なし
#
# 特記事項:
# - トークン情報のリストは以下の構造を持つ
# | TOKEN    - 切り出した字句
# | KEYWORD  - 字句に対するトークンID
# | LINE     - トークンが記述されている行番号
#
#####################################################################
sub _Lexer {
	my ($parser) = shift;

	my $result = $lex->nextToken;

	if($result) {
		$parser->{YYData}->{LINE} = $result->{LINE};
		return ($result->{KEYWORD}, $result);
	}
	else {
		return ('', undef);
	}
}

#####################################################################
# Function: Run
#
# 概要:
# 構文解析を実行し、ファイル情報を生成する。
#
# パラメータ:
# parser - パーサオブジェクト
#
# 戻り値:
# fileinfo - ファイル情報
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub Run {
	my $self = shift;
	my $parser_debug_flg = 0;

	# Parser プロト確認用。SQL抽出に埋め込むときに削除すること！
#	set_loglevel(7);

	$G_static_number = 0;
	$G_fileinfo_ref = CFileInfo->new();
	@G_classname_ident = ();

	$lex->setTarget($self->{YYData}->{INPUT});
	defined($self->{YYData}->{loglevel}) and  $self->{YYData}->{loglevel} > 10
					and $parser_debug_flg = 0x1F;
	$lex->setDebugMode($parser_debug_flg);

	$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error, yydebug => $parser_debug_flg);
}

#####################################################################
# Function: printDebugLog
#
# 概要:
# Parserのデバッグ情報を(DEBUG 7)として標準エラー出力に出力する
#
# パラメータ:
# 引数をそのままprintfに引き渡す
# フォーマットの指定は不可
#
# 戻り値:
# なし
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub printDebugLog {
	my ($log) = @_; # 引数の格納
	get_loglevel() > 6 and printf(STDERR "%s (DEBUG7) %s\n", get_localtime(), $log);
}


#####################################################################
# Function: scantree
#
# 概要:
# 指定されたノードを走査し、式情報のリスト、およびスコープ情報の
# リストを抽出する。各トークンの内容は、トークン情報で管理する。
#
# パラメータ:
# targettree - 走査対象となるトークンリスト
# result_ref - 出力結果のリスト(出力)
#
# 戻り値:
# なし
#
# 例外:
# なし
#
# 特記事項:
# - 出力結果のリストは、ノードに含まれるコード情報ごとに、下記の情報を
#   ハッシュで管理する。このハッシュ領域は、呼び出し元で準備する必要が
#   ある。
# | exprset   => @  抽出した式情報のリスト
# | scopeset  => @  抽出したスコープ情報のリスト
# | line      => $  当該式情報の行番号
#
# - 1つのトークンリストより複数のコード情報が生成されるケース(for文)が
#   存在するため、出力結果のリストはコード情報ごとに上記のハッシュが
#   格納される
#
# - exprlistは、当該ノードに存在する、式解析対象となる式情報のリスト
#   である。
#
#####################################################################
sub scantree {
    my ($targettree, $result_ref) = @_;

    my $current_hash = $result_ref->[-1]; # 現在のコード情報を格納する領域
    
    my $type = ref($targettree);
    
    if(!(defined $targettree and defined $type)) {
        croak "Parse error %%s :-- (unkown node in scantree)\n";
    }
    #
    # 単一要素の場合は、リスト化して式集合へ登録する
    #
    if($type eq 'HASH') {
        my $current_exprset = $current_hash->{exprset}->[-1];
        
        my $token = get_token($targettree->{KEYWORD}, $targettree->{TOKEN});
        push(@{$current_exprset}, $token);
        
        if(!exists $current_hash->{line}) {
            $current_hash->{line} = $targettree->{LINE};
        }
    }
    
    #
    # 配列の場合は、スコープ情報か、トークンリストか識別する
    #
    elsif($type eq 'ARRAY') {
        my $current_id = undef;
        if(scalar @$targettree != 0 and defined $targettree->[0]) {
            $current_id = $nodetypehash{$targettree->[0]};
        }
        # トークンリストがノードでない場合(要素ハッシュの集合など)は、
        # トークンリストの要素を処理する
        # 
        !defined $current_id and $current_id = $G_element_id;
                #
        # スコープ情報の場合、スコープ情報リストへ格納する
        #
        if($current_id == $G_ScopeInfo_id) {
            my $current_scopeset = $current_hash->{scopeset};
            push(@{$current_scopeset}, $targettree->[1]);
        }
        
        #
        # デリミタトークンの場合は、式情報のリストに新たなリストを追加する
        # 現時点までで抽出したトークン群で、1つの式情報と確定する
        #
        elsif($current_id == $G_Delimiter_id) {
            push(@{$current_hash->{exprset}}, []);
        }
        #
        # メタデータを格納するノードの場合：
        # 行番号を保持している場合は、当該トークンリストの行番号を、保持している
        # 行番号とする(ただしまだ行番号が未登録の場合)
        # 新規コード情報追加の場合、出力結果のリストに新規ハッシュを追加する
        #
        elsif($current_id == $G_MetaNode_id) {
            my $metadata = $targettree->[1];
            
            if(exists $metadata->{line} and !exists $current_hash->{line}) {
                $current_hash->{line} = $metadata->{line};
            }
            
            if(exists $metadata->{addcode}) {
                push(@{$result_ref}, { exprset => [[]], scopeset => []});
            }
        }
        #
        # 条件演算以外のトークンリストの場合、トークン情報のリストを
        # 生成して、式情報リストへ格納する
        #
        else {
            #
            # トークンリストよりトークン情報を生成する
            # トークンリストは、そのままコード情報のトークンリストとして格納
            # されるため、shift操作などにより、要素を削除しないこと
            #
            my $i = 0;

            # targettreeがノードの場合は、ノード名の分、ポインタをずらす
            $current_id != $G_element_id and $i++;

            while($i < scalar @{$targettree}) {
                $current_hash = $result_ref->[-1]; # 現在のコード情報の更新を行う
                defined($targettree->[$i]) and scantree($targettree->[$i], $result_ref);
                $i++;
            }
        }
    }
    return;
}

#####################################################################
# Function: scanscope
#
# 概要:
# スコープ情報を走査し、格納されているトークンの集合を抽出する。
# スコープ情報が格納するコード情報が正規化されたコードの場合、その
# 式情報リストが保持する内容を連結した文字列を抽出したトークンリスト
# に格納する。スコープ情報が格納するコード情報が、下位スコープ情報
# の場合、下位スコープ情報についてさらにスコープ情報の走査を行う。
#
# パラメータ:
# scopeinfo  - 走査対象となるスコープ情報
# exprlist   - 抽出したトークンのリスト(出力)
#
# 戻り値:
# なし
#
# 例外:
# なし
#
# 特記事項:
# - 変数情報の値がArrayInitializerの場合、平坦化する際に利用する
#
#####################################################################
sub scanscope {
    my ($scopeinfo, $exprlist) = @_;
    
    for my $code_set (@{$scopeinfo->codelist()}) {
        if($code_set->codeType() == CODETYPE_CODE) {
            for my $expr (@{$code_set->exprlist}) {
                push(@{$exprlist}, @{$expr});
            }
        } else {
            scanscope($code_set->tokenlist(0), $exprlist);
#            push(@{$exprlist}, get_token('CM_TOKEN'));
        }
    }
}



#####################################################################
# Function: create_scopeinfo
#
#
# 概要:
# スコープ情報を新規に生成する。指定されたトークンリストよりコード
# 情報を生成し、スコープ情報に格納する。
#
# パラメータ:
# tokenlist - トークンリスト
#
# 戻り値:
# コード情報
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub create_scopeinfo {
    
    my ($tokenlist) = @_;
    
    #
    # ノード名を削除する
    # tokenlistには、N_BlockStatementの集合が格納されている
    #
    
    shift @{$tokenlist};
    my $scope_info = Scope->new();

    #
    # 指定されたトークンリストすべてについて、コード情報の生成を
    # 行う
    #
    for my $node (@{$tokenlist}) {
        
        next if !defined($node);
    
        #
        # 当該トークン(ノード)がスコープ情報の場合は、その下位スコープ情報
        # に対するコード情報を生成して、現スコープ情報に格納する
        #
        if(equal_nodetype($node, 'N_ScopeInfo')) {
                    
            my $child_scope1 = $node->[1];
            $child_scope1->parent($scope_info);
                    
            push(@{$scope_info->codelist()},
                         create_codeset_for_scope($child_scope1));
                    
        }
        #
        # 当該トークン(ノード)が変数情報の場合は、そのトークン
        # に対する変数情報をスコープ情報に格納する
        elsif(ref($node) eq 'HASH' and exists $node->{VARIABLE}){

        	push(@{$scope_info->varlist()} , @{$node->{VARIABLE}});
        	
        }
        #
        # 当該トークン(ノード)がスコープ情報以外の場合は、そのトークン
        # に対するコード情報を生成して、現スコープ情報に格納する
        #
        else {
            my $codeset = create_codeset_for_code($node);
            push(@{$scope_info->codelist()}, @{$codeset->{CODE}});
            
            #
            # 当該ノード内に下位スコープが存在した場合は、スコープ間の
            # 親子関係を構築する        
            #
            for my $child_scope2 (@{$codeset->{SCOPE}}) {
                $child_scope2->parent($scope_info);
            }
        }
    }
    
    return $scope_info;
}

#####################################################################
# Function: create_codeset_for_scope
#
#
# 概要:
# スコープ情報を格納するコード情報を新規に生成する。
#
# パラメータ:
# scope - スコープ情報
#
# 戻り値:
# コード情報
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub create_codeset_for_scope {
    
    my ($scope) = @_;

    my $codeset = CodeSet->new();
    $codeset->codeType(CODETYPE_SCOPE);
    $codeset->tokenlist(0, $scope);
    return $codeset;
}


#####################################################################
# Function: create_codeset_for_code
#
#
# 概要:
# トークンリストを格納するコード情報を新規に生成する。トークンリスト
# を解析して、式集合を抽出し格納する。また、式に含まれるスコープ情報を
# 抽出した場合は、スコープ情報ごとにコード情報を生成する。
#
# パラメータ:
# tokenlist - トークンリスト
#
# 戻り値:
# - コード情報のリストのリファレンス、および子スコープ情報のリストのリファレンス
#
# 特記事項:
# - 返却はハッシュに格納して返却する
# | CODE  => コード情報のリストのリファレンス
# | SCOPE => 子スコープ情報のリストのリファレンス
#####################################################################
sub create_codeset_for_code {
    my ($tokenlist) = @_;
    
    my @codelist = ();
    my @scopelist = ();

    #
    # トークンリストの解析結果
    #
    my $result_ref = [
        {
            exprset  => [[]],
            scopeset => [],
        }
    ];

    scantree($tokenlist, $result_ref);
    
    for my $current_codeinfo (@{$result_ref}) {
        #
        # トークンリストを格納するコード情報を生成する
        #
        my $codeset = CodeSet->new(linenumber => $current_codeinfo->{line});
        $codeset->codeType(CODETYPE_CODE);
        $codeset->tokenlist(0, $tokenlist);
        push(@{$codeset->exprlist()}, @{$current_codeinfo->{exprset}});

        push(@codelist, $codeset);

        #
        # トークンリストよりスコープ情報を抽出した場合は、スコープ情報を含む
        # コード情報を生成する
        #                
        if(scalar @{$current_codeinfo->{scopeset}} > 0) {
            for my $scope (@{$current_codeinfo->{scopeset}}) {
                push(@codelist, create_codeset_for_scope($scope));
                push(@scopelist, $scope);
            }
        }
    }




    
    return {CODE => \@codelist, SCOPE => \@scopelist};
}

#####################################################################
# Function: refer_metanode
#
#
# 概要:
# 指定されたノードがMetaNodeである場合、その内容を返却する
#
# パラメータ:
# node    - ノード情報
#
# 戻り値:
# MetaNodeを保持している場合、その内容。保持していない場合は未定義値
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub refer_metanode {
    my ($node) = @_;
    
    if(defined $node and ref($node) eq 'ARRAY'
        and equal_nodetype($node->[1], 'N_MetaNode')) {   
        return $node->[1]->[1];
    }
    undef;
}

#####################################################################
# Function: create_linenode
#
# 概要:
# 指定されたトークンの行番号を保持するMetaNodeを生成する
#
# パラメータ:
# token    - ノード情報
#
# 戻り値:
# MetaNode - 行番号を保持するMetaNode
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub create_linenode {
    my ($token) = @_;
    return ['N_MetaNode', {line => $token->{LINE}}];
}

#####################################################################
# Function: create_addcode
#
# 概要:
# トークンリスト解析時に新規コード情報として情報を格納する指示を
# 追加するMetaNodeを生成する
#
# パラメータ:
# なし
#
# 戻り値:
# MetaNode - 新規コード情報追加を指示するMetaNode
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub create_addcode {
    return ['N_MetaNode', {addcode => 1}];
}


#####################################################################
# Function: equal_nodetype
#
#
# 概要:
# 指定されたノードがkeywordが示すノード種別の場合、真を返却する。
# 指定されたノードが定義されていない、またはノードではない場合は
# 偽を返却する
#
# パラメータ:
# node    - ノード情報
# keyword - ノード種別を示す文字列 
#
# 戻り値:
# 真偽値
#
# 例外:
# - ノード情報の構造が不正な場合
# - ノード種別を示す文字列が不正な場合
#
# 特記事項:
# なし
#
#####################################################################
sub equal_nodetype {
    my ($node, $keyword) = @_;
    my $b = 0;
    if(defined $node and ref($node) eq 'ARRAY'
             and $node->[0] =~ m{N_}xms) {
        $b = $nodetypehash{$node->[0]} == $nodetypehash{$keyword};
    }
    return $b;
}

#####################################################################
# Function: create_VariableInfo
#
#
# 概要:
# 変数情報を新規に生成する。
#
# パラメータ:
# name      - 変数名のトークン
# typeinfo  - 型のトークンリスト(N_typeノード)
# typetype  - 型の識別情報(NORMAL or ARRAYという文字列)
# valueinfo - 値のトークンリスト(N_VariableInitializerノード)
#
# 戻り値:
# 変数情報
#
# 例外:
# なし
#
# 特記事項:
# - 値として格納される内容はトークンリストとなる
#
#####################################################################
sub create_VariableInfo {
    my ($name, $typeinfo, $typetype, $valueinfo) = @_;

    #
    # 型名を取得する
    # String, StringBufferの型名に修飾子が付与されている場合は取り除く
    #
    my $result_ref = [
        {
            exprset  => [[]],
            scopeset => [],
        }
    ];
    scantree($typeinfo, $result_ref);
    
    my $line = $result_ref->[0]->{line};
    
    #
    # 型名は、収集した式リストの「最初の式リストの最後の要素」を取得する
    # - 先頭から要素を参照し、'['の直前の型名か、要素の最後の型名を取得する
    # - '['を検出した場合は、型種別を'ARRAY'に変更する
    my ($index, $result_of_exprset);
    for($index = 0, $result_of_exprset = $result_ref->[0]->{exprset}->[0];
        $index < scalar @{$result_of_exprset};
        $index++) {
        
        if($result_of_exprset->[$index]->token() eq '[') {
            $typetype = 'ARRAY';
            last;
        }
    }
    my $typename = $result_of_exprset->[$index - 1]->token();

    #
    # 型種別が配列の場合、配列を示す文字列を付与する
    # （C言語版では処理を行わない）
    #
    #if(defined($typetype) and $typetype eq 'ARRAY') {
    #    $typename = $typename . '[]';
    #}
	#

    my $declarationType = 0;

    #
    # ホスト変数宣言内の場合、フラグを真にする
    #
    if($G_declaresection_flg) {
        $declarationType = int($declarationType) | TYPE_HOST;
    }

    my $var_info = CVariableInfo->new(name => $name->{TOKEN}, type => $typename, linenumber => $line, declarationType => $declarationType);

    #
    # トークンリストから値を取得する
    # scantreeの結果として取得した式リスト、およびスコープ情報リスト内に
    # 格納されているトークンをひとつずつ抽出し、tokenlistに格納する 
    #
    if(defined $valueinfo) {
        $result_ref->[0]->{exprset} = [[]];
        $result_ref->[0]->{scopeset} = [];
        scantree($valueinfo, $result_ref);
        
        my $tokenlist = $var_info->value();
        my $exprset = [];
        map { push(@{$tokenlist}, $_)} @{$result_ref->[0]->{exprset}->[0]};
        map {scanscope($_, $exprset); push(@{$tokenlist}, @{$exprset})}
            @{$result_ref->[0]->{scopeset}};
    
        #
        # 変数情報の終端を示すVARDECL_DELIMITERトークンを追加する
        #
        my $delimiter = get_token('VARDECL_DELIMITER');
        push(@{$tokenlist}, $delimiter);
    }
    return $var_info;
}

#####################################################################
# Function: create_functioninfo
#
#
# 概要:
# メソッド情報を新規に生成する。
#
# パラメータ:
# name      - メソッド名
# scope     - ルートスコープ情報
#
# 戻り値:
# メソッド情報
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub create_functioninfo {
    my ($name, $scope) = @_;
    
    my $function = FunctionInfo->new();
    $function->functionname($name);
    $function->rootscope_ref($scope->[1]);
    
    return $function;
}

#####################################################################
# Function: get_token
#
#
# 概要:
# トークンIDに対するトークン情報を返却する。トークン情報オブジェクト
# プールにオブジェクトが存在する場合は、そのトークン情報を返却する。
# 抽出し、連結した文字列を返却する。
#
# パラメータ:
# keyword - トークンID
# token   - 切り出した文字列
# 
#
# 戻り値:
# トークンIDに対するトークン情報
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub get_token {
    my ($keyword, $token) = @_;
    
    my $tokeninfo;
    
    #
    # トークンIDがキャッシュ対象であるか判別する
    #
    if(exists $lookup{$keyword}) {
        
        #
        # キャッシュ対象の場合、トークン情報をキャッシュより取得する
        # 取得できなかった場合は、新規に作成してキャッシュへ登録する
        #
        $tokeninfo = $G_tokenchace{$keyword};
        if(!defined $tokeninfo) {
            $tokeninfo = Token->new(token => $lookup{$keyword}, id => $tokenId{$keyword});
            $G_tokenchace{$keyword} = $tokeninfo;
        }
    } else {
        #
        # キャッシュ対象でない場合は、新規にトークン情報を生成する
        #
        $tokeninfo = Token->new(token => $token, id => $tokenId{$keyword});
    }
    return $tokeninfo;
}


#####################################################################
# Function: create_forvar_control
#
#
# 概要:
# N_ForControlノードを生成し、返却する。
#
# パラメータ:
# type - PrimaryTypeの内容
# rest - ForVarControlRestの内容
# 
#
# 戻り値:
# N_ForControlノード
#
# 例外:
# なし
#
# 特記事項:
# なし
#
#####################################################################
sub create_forvar_control {
    my ($type, $rest) = @_;
    my $for_init = ['N_forInit', $type, $rest->[1]];
    my $for_ctrl = ['N_ForControl', $for_init, create_addcode(), $rest->[2], create_addcode(), $rest->[3]];
    $for_ctrl
}
